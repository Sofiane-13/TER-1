/*
 * generated by Xtext 2.14.0-SNAPSHOT
 */
package com.aelos.xtext.mappingassistance.serializer;

import com.aelos.xtext.mappingassistance.mappingAssistance.Import;
import com.aelos.xtext.mappingassistance.mappingAssistance.InstanceComp;
import com.aelos.xtext.mappingassistance.mappingAssistance.Mapping;
import com.aelos.xtext.mappingassistance.mappingAssistance.MappingAssistancePackage;
import com.aelos.xtext.mappingassistance.mappingAssistance.MockName;
import com.aelos.xtext.mappingassistance.mappingAssistance.Mocks;
import com.aelos.xtext.mappingassistance.mappingAssistance.Model;
import com.aelos.xtext.mappingassistance.mappingAssistance.ObserveurName;
import com.aelos.xtext.mappingassistance.mappingAssistance.Observeurs;
import com.aelos.xtext.mappingassistance.mappingAssistance.ServiceName;
import com.aelos.xtext.mappingassistance.mappingAssistance.Testedcomposant;
import com.aelos.xtext.mappingassistance.mappingAssistance.Testedservice;
import com.aelos.xtext.mappingassistance.mappingAssistance.Variable;
import com.aelos.xtext.mappingassistance.services.MappingAssistanceGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MappingAssistanceSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MappingAssistanceGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MappingAssistancePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MappingAssistancePackage.IMPORT:
				if (rule == grammarAccess.getAbstractModelRule()) {
					sequence_AbstractModel_Import(context, (Import) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getImportRule()) {
					sequence_Import(context, (Import) semanticObject); 
					return; 
				}
				else break;
			case MappingAssistancePackage.INSTANCE_COMP:
				sequence_InstanceComp(context, (InstanceComp) semanticObject); 
				return; 
			case MappingAssistancePackage.MAPPING:
				sequence_Mapping(context, (Mapping) semanticObject); 
				return; 
			case MappingAssistancePackage.MOCK_NAME:
				sequence_MockName(context, (MockName) semanticObject); 
				return; 
			case MappingAssistancePackage.MOCKS:
				sequence_Mocks(context, (Mocks) semanticObject); 
				return; 
			case MappingAssistancePackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MappingAssistancePackage.OBSERVEUR_NAME:
				sequence_ObserveurName(context, (ObserveurName) semanticObject); 
				return; 
			case MappingAssistancePackage.OBSERVEURS:
				sequence_Observeurs(context, (Observeurs) semanticObject); 
				return; 
			case MappingAssistancePackage.SERVICE_NAME:
				sequence_ServiceName(context, (ServiceName) semanticObject); 
				return; 
			case MappingAssistancePackage.TESTEDCOMPOSANT:
				sequence_Testedcomposant(context, (Testedcomposant) semanticObject); 
				return; 
			case MappingAssistancePackage.TESTEDSERVICE:
				sequence_Testedservice(context, (Testedservice) semanticObject); 
				return; 
			case MappingAssistancePackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractModel returns Import
	 *
	 * Constraint:
	 *     (importedNamespace=QualifiedNameWithWildcard obs+=Observeurs* mock+=Mocks* testedserv+=Testedservice+ testedcomp+=Testedcomposant)
	 */
	protected void sequence_AbstractModel_Import(ISerializationContext context, Import semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Import returns Import
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(ISerializationContext context, Import semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MappingAssistancePackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingAssistancePackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InstanceComp returns InstanceComp
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_InstanceComp(ISerializationContext context, InstanceComp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MappingAssistancePackage.Literals.INSTANCE_COMP__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingAssistancePackage.Literals.INSTANCE_COMP__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInstanceCompAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Mapping returns Mapping
	 *
	 * Constraint:
	 *     (nameVarMode+=[Variable|ID] nameVarTest+=[Variable|ID])
	 */
	protected void sequence_Mapping(ISerializationContext context, Mapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MockName returns MockName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_MockName(ISerializationContext context, MockName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MappingAssistancePackage.Literals.MOCK_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingAssistancePackage.Literals.MOCK_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMockNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Mocks returns Mocks
	 *
	 * Constraint:
	 *     (mockname+=[MockName|ID] nameComp+=[InstanceComp|ID] nameServ1+=[ServiceName|ID])
	 */
	protected void sequence_Mocks(ISerializationContext context, Mocks semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     function+=AbstractModel+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ObserveurName returns ObserveurName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ObserveurName(ISerializationContext context, ObserveurName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MappingAssistancePackage.Literals.OBSERVEUR_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingAssistancePackage.Literals.OBSERVEUR_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObserveurNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Observeurs returns Observeurs
	 *
	 * Constraint:
	 *     (obsname+=[ObserveurName|ID] nameComp+=[InstanceComp|ID] nameServ1+=[ServiceName|ID] nameComp+=[InstanceComp|ID] nameServ2+=[ServiceName|ID])
	 */
	protected void sequence_Observeurs(ISerializationContext context, Observeurs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ServiceName returns ServiceName
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ServiceName(ISerializationContext context, ServiceName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MappingAssistancePackage.Literals.SERVICE_NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingAssistancePackage.Literals.SERVICE_NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getServiceNameAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Testedcomposant returns Testedcomposant
	 *
	 * Constraint:
	 *     nameComp+=[InstanceComp|ID]
	 */
	protected void sequence_Testedcomposant(ISerializationContext context, Testedcomposant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Testedservice returns Testedservice
	 *
	 * Constraint:
	 *     (nameComp+=[InstanceComp|ID] nameServ1+=[ServiceName|ID])
	 */
	protected void sequence_Testedservice(ISerializationContext context, Testedservice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     (name=ID type=Type)
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MappingAssistancePackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingAssistancePackage.Literals.VARIABLE__NAME));
			if (transientValues.isValueTransient(semanticObject, MappingAssistancePackage.Literals.VARIABLE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MappingAssistancePackage.Literals.VARIABLE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableAccess().getTypeTypeEnumRuleCall_2_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
}
